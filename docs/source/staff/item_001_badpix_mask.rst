Update Bad Pixel Mask for X-ray Detector
========================================

This script updates the bad-pixel mask for an X-ray detector by combining the original 
mask (downloaded from the detector) with a new mask generated by post-processing. The 
detector requires its mask in a specific TIFF format with 32-bit data and vendor-specific 
metadata. 

The original mask contains previously known bad pixels. New bad pixel locations are 
identified using *Dioptas*, a diffraction analysis software. However, due to the detector 
firmware, pixels already masked in hardware are removed from the XRD file before 
Dioptas can see them. As a result, Dioptas only detects newly problematic pixels and 
exports a mask as a ``.mask`` file â€” which is actually just a PNG image with nonzero 
(white) values marking new bad pixels.

This script performs the following:

- Reads the original bad-pixel TIFF mask (preserving its metadata and format)
- Loads the new bad-pixel positions from the Dioptas-generated PNG
- Vertically flips the PNG image to match detector orientation
- Performs a pixel-wise logical OR between the two masks
- Writes the result back to a new TIFF file with the same structure as the original

The resulting TIFF file is suitable for re-upload to the detector.

Usage Instructions
------------------

1. Obtain the original bad-pixel mask from the detector and save it as ``original.tif``.

2. Export the new bad-pixel mask from Dioptas. Rename the resulting ``.mask`` file 
   (which is a PNG) to something like ``new_mask.png``.

3. Place ``original.tif``, ``new_mask.png``, and the Python script in the same directory.

4. Edit the script if needed to update the paths::

       original_path = 'original.tif'
       png_path = 'new_mask.png'
       new_tif_path = 'updated_badpix_mask.tif'

5. Run the script using Python 3::

       python combine_masks.py

6. The output file ``updated_badpix_mask.tif`` will be created, combining old and new 
   bad pixel locations, and will remain compatible with the detector software.

Script
------

.. code-block:: python

    from tifffile import TiffFile
    from PIL import Image
    import numpy as np
    import shutil

    # --- Define paths
    original_path = 'original.tif'
    new_tif_path = 'updated_badpix_mask.tif'
    png_path = 'new_mask.png'

    # --- Copy the original file (preserve header)
    shutil.copyfile(original_path, new_tif_path)

    # --- Step 1: Read original TIFF metadata and pixel data
    with TiffFile(original_path) as tif:
        page = tif.pages[0]
        offset = page.dataoffsets[0]
        dtype = page.dtype
        shape = page.shape
        original_data = page.asarray()

    # --- Step 2: Load the PNG as 8-bit grayscale, resize, and flip vertically
    img = Image.open(png_path).convert('L')
    img = img.resize((shape[1], shape[0]))  # Resize to match original (width, height)
    png_data = np.array(img)
    png_data = np.flipud(png_data)  # Flip PNG vertically to match TIFF layout

    # --- Step 3: Threshold to binary (0 or 1)
    new_data = (png_data > 0).astype(np.uint8)
    original_binary = (original_data > 0).astype(np.uint8)

    # --- Step 4: Perform logical OR
    combined_data = ((original_binary | new_data) > 0).astype(dtype)

    # --- Step 5: Sanity checks
    assert combined_data.shape == shape
    assert combined_data.dtype == dtype

    # --- Step 6: Overwrite pixel data in the new file
    with open(new_tif_path, 'r+b') as f:
        f.seek(offset)
        f.write(combined_data.tobytes())

    print("New TIFF written with logical OR of original and PNG.")